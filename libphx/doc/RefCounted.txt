--- Reference Counting in PHX --------------------------------------------------

  Many of the opaque structures in PHX are reference-counted. Ref counting is a
  fast, intuitive, and unobtrusive approach to managing the lifetimes of shared
  resources.

  For the most part, using RefCounted objects requires no special attention, and
  users of the PHX API can often get away without even knowing whether the
  underlying object is RefCounted or not.

  There is, however, a specific situation in which refcounting must be used and
  understood: when a resource is going to be owned by different users with
  different lifetimes, and it is not clear which user is responsible for the
  resource's memory. In this case, we must ensure that each user correctly
  increments the resource's reference count upon acquisition to ensure that the
  object will not be destroyed while they still hold a reference.

  Similarly, we must ensure that each user frees acquired resource upon
  destruction. For RefCounted objects, there is no explicit 'release' function
  to decrement the reference count. Instead, the *_Free method of the object
  in question transparently performs decrementing before deciding whether to
  actually free the resource's memory or not.

  There is an explicit *_Acquire method for all RefCounted objects. If an object
  in PHX has an *_Acquire method, then it is reference-counted and users must
  objey the rules below.

--- Rules for Using Reference-Counted Objects ----------------------------------

    -> New RefCounted objects are always returned by the function that created
       them with a reference count of 1. The caller should thus store the
       returned object WITHOUT attempting to increment the count.

    -> If a RefCounted object pointer is *copied* from an existing pointer and
       stored beyond the local scope, the object storing the copied pointer MUST
       increment the reference count by calling *_Acquire on the object as soon
       as the pointer is stored. Failing to do so may result in
       access-after-free errors.

    -> A call to *_Acquire MUST be paired with a corresponding call to *_Free.
       If one object acquires a reference to another, the acquiring object must
       free the acquired object when finished with it. Failing to do so will
       result in memory leaks.

    -> If circular references are possible, they must be explicitly handled by
       the code in which they are made possible. PHX reference counting makes
       no attempt to deal with such situations, as they are generally trivial
       to avoid.

    -> Reference counts should NEVER be modified directly.

    -> RefCounted objects are not thread-safe.

--------------------------------------------------------------------------------
